/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdafx.h>
#include "jni.h"
#include "SimpleUEUpdater.h"
#include <iostream>
#include <stdlib.h>
#include <math.h>

#include <exception>

/* Header for class redcas_numerical_NativeUEKT */

#ifndef _Included_redcas_numerical_NativeUEKT
#define _Included_redcas_numerical_NativeUEKT
#ifdef __cplusplus
extern "C" {
#endif




#undef redcas_numerical_NativeUEKT_TYPE_GAMMA
#define redcas_numerical_NativeUEKT_TYPE_GAMMA 1L
#undef redcas_numerical_NativeUEKT_TYPE_LOGNORMAL
#define redcas_numerical_NativeUEKT_TYPE_LOGNORMAL 2L
#undef redcas_numerical_NativeUEKT_RESULT_OK
#define redcas_numerical_NativeUEKT_RESULT_OK 0L

void copyNativeToJava(JNIEnv * env, jdoubleArray javaArr, double *nativeArr, int size);

jint handleNativeUEKTUpdate
  (JNIEnv * env, jdouble nu, jdouble tau, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray vals, jdoubleArray cdfs, jint size, UEPair updatePair);

jint handleNativeUEKTUpdateTab
  (JNIEnv * env, jdoubleArray prVals, jdoubleArray prCDFs, jint prSize, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size, UEPair updatePair);

/*
 * Class:     redcas_numerical_NativeUEKT
 * Method:    nativeLogPoisson
 * Signature: (DD[I[D[D[D[D[DI)I
 */
JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeLogPoisson
  (JNIEnv * env, jclass, jdouble nu, jdouble tau, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size)
{
	return handleNativeUEKTUpdate(env,nu,tau,evVals,evProbs,tmVals,tmProbs,jvals,jcdfs,size,UE_LOGNORMAL_POISSON);
}

/* Constructs a tabular distribution representing the weighted posterior 
 * distribution that is the result of a Gamma Poisson updating procedure.
 *
 * INPUTS:
 *   env - 
 *   alpha - Gamma prior shape parameter
 *   lambda - Gamma prior scale parameter
 *   evVals - array of event values
 *   evProbs - array of event probabilities
 *   tmVals - array of time values
 *   tmProbs - array of time probabilities
 *   jvals - array of posterior values
 *   jcdfs - array of posterior cdfs
 *   size - points in posterior table
 *   
 */
JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeGamPoisson
  (JNIEnv * env, jclass, jdouble alpha, jdouble lambda, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size)
{
	return handleNativeUEKTUpdate(env,alpha,1/lambda,evVals,evProbs,tmVals,tmProbs,jvals,jcdfs,size,UE_GAMMA_POISSON);
}

JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeBetBinomial
  (JNIEnv * env, jclass, jdouble nu, jdouble tau, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size)
{
	return handleNativeUEKTUpdate(env,nu,tau,evVals,evProbs,tmVals,tmProbs,jvals,jcdfs,size,UE_BETA_BINOMIAL);
}

JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeLogBinomial
  (JNIEnv * env, jclass, jdouble nu, jdouble tau, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size)
{
	return handleNativeUEKTUpdate(env,nu,tau,evVals,evProbs,tmVals,tmProbs,jvals,jcdfs,size,UE_LOGNORMAL_BINOMIAL);
}

JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeTabPoisson
  (JNIEnv * env, jclass, jdoubleArray priorVals, jdoubleArray priorCDFs, jint priorSize,
   jintArray evVals, jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs,
   jdoubleArray posteriorVals, jdoubleArray posteriorCDFs, jint posteriorSize)
{
	return handleNativeUEKTUpdateTab(env,priorVals,priorCDFs,priorSize,evVals,evProbs,
		tmVals,tmProbs,posteriorVals,posteriorCDFs,posteriorSize,UE_TABULAR_POISSON);
}

JNIEXPORT jint JNICALL Java_redcas_numerical_NativeUEKT_nativeTabBinomial
  (JNIEnv * env, jclass, jdoubleArray priorVals, jdoubleArray priorCDFs, jint priorSize,
   jintArray evVals, jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs,
   jdoubleArray posteriorVals, jdoubleArray posteriorCDFs, jint posteriorSize)
{
	return handleNativeUEKTUpdateTab(env,priorVals,priorCDFs,priorSize,evVals,evProbs,
		tmVals,tmProbs,posteriorVals,posteriorCDFs,posteriorSize,UE_TABULAR_BINOMIAL);
}

///////////////////////////////////////////////////////////////////////////

/**
 * Handles calls to nativeTabularPoisson and nativeTabularBinomial methods.
 *
 * These methods are used to update a tabular prior distribution based on 
 * uncertain evidence, using the Weighted Posterior method. This methods
 * provides the interface between the JNI calling routine and the C++
 * SimpleUEUpdater class, which performs the actual update.
 * 
 * INPUTS:
 *   env - Java environment handle
 *   prVals - array of prior values
 *   prCDFs - array of prior cdf
 *   prSize - prior size
 *   evVals - array of event values
 *   evProbs - array of event probabilities
 *   tmVals - array of exposure (time/demand) values
 *   tmProbs - array of exposure probabilities
 *   jvals - array of posterior values
 *   jcdfs - array of posterior cdfs
 *   size - size of posterior tabular distribution
 *   updatePair - type of update
 *
 * OUTPUT:
 *   0 if update was successful.
 */
jint handleNativeUEKTUpdateTab
  (JNIEnv * env, jdoubleArray prVals, jdoubleArray prCDFs, jint prSize, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size, UEPair updatePair)
{
	// construct updater object
	SimpleUEUpdater * updater = new SimpleUEUpdater();

	// copy tabular prior to updater
	jdouble * prValArr = env->GetDoubleArrayElements(prVals,NULL);
	jdouble * prCDFArr = env->GetDoubleArrayElements(prCDFs,NULL);
	double * nPrVals = new double [prSize]; // native double array of prior values
	double * nPrCDFs = new double [prSize]; // native double array of prior cdfs
	for (int ij = 0 ; ij < prSize ; ij++) {
		nPrVals[ij] = prValArr[ij];
		nPrCDFs[ij] = prCDFArr[ij];
	}
	updater->setPrior(nPrVals,nPrCDFs,prSize);
	delete [] nPrVals;
	delete [] nPrCDFs;
	env->ReleaseDoubleArrayElements(prVals,prValArr,JNI_ABORT);
	env->ReleaseDoubleArrayElements(prCDFs,prCDFArr,JNI_ABORT);

	// adding evidence entries to updater object
	jint * evValArr = env->GetIntArrayElements(evVals,NULL);
	jdouble * evProbArr = env->GetDoubleArrayElements(evProbs,NULL);
	jdouble * tmValArr = env->GetDoubleArrayElements(tmVals,NULL);
	jdouble * tmProbArr = env->GetDoubleArrayElements(tmProbs,NULL);
	bool entryFound = false;
	for (int i = 0 ; i < 4 ; i++) {
	   if (evProbArr[i] > 0 && evValArr[i] >= 0) {
		   for (int j = 0 ; j < 4 ; j++) {
			   if (tmProbArr[j] > 0 && tmValArr[j] > 0) {
				   updater->addInterpretation(evValArr[i],tmValArr[j],evProbArr[i]*tmProbArr[j]);
			       entryFound = true;
			   }
		   }
	   }
	}
	env->ReleaseDoubleArrayElements(tmProbs,tmProbArr,JNI_ABORT);
	env->ReleaseDoubleArrayElements(tmVals,tmValArr,JNI_ABORT);
	env->ReleaseDoubleArrayElements(evProbs,evProbArr,JNI_ABORT);
	env->ReleaseIntArrayElements(evVals,evValArr,JNI_ABORT);

	// perform update
	double * nvals = new double[size];
	double * ncdfs = new double[size];
	int retval = 1;
	if (entryFound) {
	   updater->normalizeInterpretations();
	   retval = updater->constructCDF(updatePair,nvals,ncdfs,size);
       copyNativeToJava(env, jvals, nvals, size);
       copyNativeToJava(env, jcdfs, ncdfs, size);
	}
	delete [] nvals;
	delete [] ncdfs;

	delete updater;

	return retval;
}

/**
 * Handles calls to native[xxx]Poisson and native[xxx]Binomial methods.
 *
 * These methods are used to update a parametric prior distribution based on 
 * uncertain evidence, using the Weighted Posterior method. This methods
 * provides the interface between the JNI calling routine and the C++
 * SimpleUEUpdater class, which performs the actual update.
 * 
 * INPUTS:
 *   env - Java environment handle
 *   nu - first parameter of prior distribution
 *   tau - second parameter of prior distribution.
 *   prSize - prior size
 *   evVals - array of event values
 *   evProbs - array of event probabilities
 *   tmVals - array of exposure (time/demand) values
 *   tmProbs - array of exposure probabilities
 *   jvals - array of posterior values
 *   jcdfs - array of posterior cdfs
 *   size - size of posterior tabular distribution
 *   updatePair - type of update
 *
 * OUTPUT:
 *   0 if update was successful.
 */
jint handleNativeUEKTUpdate
  (JNIEnv * env, jdouble nu, jdouble tau, jintArray evVals, 
   jdoubleArray evProbs, jdoubleArray tmVals, jdoubleArray tmProbs, 
   jdoubleArray jvals, jdoubleArray jcdfs, jint size, UEPair updatePair)

{
	jint * evValArr = env->GetIntArrayElements(evVals,NULL);
	jdouble * evProbArr = env->GetDoubleArrayElements(evProbs,NULL);
	jdouble * tmValArr = env->GetDoubleArrayElements(tmVals,NULL);
	jdouble * tmProbArr = env->GetDoubleArrayElements(tmProbs,NULL);

	SimpleUEUpdater * updater = new SimpleUEUpdater();

//	cout << "Prior " << nu << " , " << tau << endl;

//	for (int zk = 0 ; zk < 4 ; zk++) {
//		cout << " - " << evValArr[zk] << " " << evProbArr[zk] << " " << tmValArr[zk] << " " << tmProbArr[zk] << endl;
//	}

	updater->setPrior(nu,tau);

	bool entryFound = false;

//	cout << "Adding entries" << endl;

	for (int i = 0 ; i < 4 ; i++) {
	   if (evProbArr[i] > 0 && evValArr[i] >= 0) {
		   for (int j = 0 ; j < 4 ; j++) {
			   if (tmProbArr[j] > 0 && tmValArr[j] > 0) {
//				   cout << "Adding " << evValArr[i];
//				   cout << " , " << tmValArr[j];
//				   cout << " , " << evProbArr[i]*tmProbArr[j] << endl;
				   updater->addInterpretation(evValArr[i],tmValArr[j],evProbArr[i]*tmProbArr[j]);
			       entryFound = true;
			   }
		   }
	   }
	}

//	cout << "Entries added." << endl;

	env->ReleaseDoubleArrayElements(tmProbs,tmProbArr,JNI_ABORT);
	env->ReleaseDoubleArrayElements(tmVals,tmValArr,JNI_ABORT);
	env->ReleaseDoubleArrayElements(evProbs,evProbArr,JNI_ABORT);
	env->ReleaseIntArrayElements(evVals,evValArr,JNI_ABORT);


	double * nvals = new double[size];
	double * ncdfs = new double[size];
	
	int retval = 1;

	if (entryFound) {
	   updater->normalizeInterpretations();

	   try {
	      retval = updater->constructCDF(updatePair,nvals,ncdfs,size);
	   } catch(int ec) {
	   } catch(...) {
	   }

       copyNativeToJava(env, jvals, nvals, size);
       copyNativeToJava(env, jcdfs, ncdfs, size);
	}

	delete updater;

	delete [] nvals;
	delete [] ncdfs;
	return retval;
}

#ifdef __cplusplus
}
#endif
#endif
